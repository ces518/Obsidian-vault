
서킷 브레이커는 장애 전파를 막아 시스템을 보호하지만, **역으로 테스트와 운영을 더 까다롭게 만든다.**  
운영에서는 오류율·타이머·시도 횟수에 따라 **closed/open/half-open** 상태가 계속 바뀌고, 이 전이가 **트래픽 분포와 사용자 행동까지 바꿔** 시스템의 병목 위치가 달라진다.

### 1) 상태 전이 재현이 어렵다

테스트에서 운영과 같은 상황을 만들려면 다음을 모두 맞춰야 한다.

- 오류가 **언제**, **몇 번** 발생했는지
    
- 임계값(threshold)을 **넘었는지**
    
- 현재 상태가 **open인지 / half-open인지**
    
- 리셋 타이머가 **얼마나 남았는지**
    

### 2) 부하 테스트가 왜곡된다

부하 테스트 중 일부 오류 요청 때문에 서킷 브레이커가 **open** 되면,

- 업스트림은 계속 요청을 보내도
    
- 서킷 브레이커가 차단해서 **다운스트림은 더 이상 부하를 받지 않는다**
    

그래서 원래 보고 싶던 **다운스트림의 처리 한계(병목 지점)**를 측정하기가 어려워진다.  
→ “한계 측정”이 아니라 “차단 동작 측정”이 되어버림.

### 3) 다운스트림은 살지만 업스트림이 먼저 죽을 수 있다

서킷 브레이커가 open이면 업스트림은 fallback/error 처리로 넘어간다.  
fallback이 폭주하면 업스트림의 CPU/DB/캐시 사용이 급증해서 **보호된 다운스트림이 아니라 업스트림이 장애날 수 있다.**

여기에 **사용자 재시도**가 겹치면 더 위험해진다.

- 다운스트림이 느릴 때는 사용자가 “로딩 중”을 보고 **재시도를 늦게** 한다
    
- 하지만 CB가 open이면 요청이 **즉시 실패**하므로 사용자는 더 빨리 재시도한다(또는 클라이언트/SDK가 즉시 재시도)
    
- 결과적으로 업스트림에는 **짧은 간격의 재시도 트래픽이 더 촘촘하게 쌓여**, 업스트림이 더 빨리 죽을 수 있다  
    → “다운스트림 보호”가 “업스트림 재시도 폭탄”으로 바뀜
    

### 4) 튜닝 포인트가 많고 운영/테스트가 다르다

설정값(실패율 threshold, 리셋 타이머, half-open 시도 횟수, 롤링 윈도 등)은

- 트래픽 패턴에 따라 최적값이 달라지고
    
- 테스트 환경과 운영 환경이 달라서
    
- 부하 상황에서 “적절한 값”을 판단하기가 어렵다
    

결국 **테스트 변수가 폭증**한다.

---

## 운영 관점에서 추가로 생기는 문제

### A) “관측되는 장애”가 바뀐다

CB가 동작하면 다운스트림의 에러/지연이 사용자에게 그대로 노출되지 않고,  
업스트림의 **fallback 성공률, 즉시 실패율, 재시도율** 같은 지표가 핵심이 된다.  
즉, 운영에서 봐야 할 대상이 **다운스트림 성능 → 업스트림의 차단/대체 동작 품질**로 이동한다.

### B) 복구 구간이 더 불안정해질 수 있다

open → half-open 전환 시점에

- 소량의 탐색 트래픽이 흘러들어가고
    
- 여기서 흔들리면 다시 open으로 돌아가며
    
- 사용자/클라이언트 재시도가 겹치면 업스트림 트래픽이 출렁인다
    

운영에서는 이 구간이 **“복구 중 flapping(열렸다 닫혔다 반복)”**으로 보이고, 장애가 길어지기 쉽다.

### C) 대응 전략이 함께 묶여야 한다

CB만 켜면 끝이 아니라, 운영에서는 보통 같이 설계해야 한다.

- **재시도 정책**(횟수/간격/지수 백오프/지터)
    
- **fallback의 비용**(DB/Redis 호출이 fallback에서 폭주하지 않는지)
    
- **rate limit / queue / shed load**(업스트림 보호)
    
- 알림은 “다운스트림 장애”뿐 아니라 **CB open 비율/기간**도 함께 봄
    

---

## 예시로 기억하기 (Order → Payment)

부하 테스트 중 카드사 API가 간헐적으로 500을 내서 실패율이 threshold를 넘으면 **CB가 open**됨 → 이후 Payment로 트래픽이 안 가서 **Payment 한계 측정 불가**.  
동시에 Order는 fallback 폭주 + **즉시 실패로 사용자 재시도 가속** → **Order가 먼저 터질 수 있음**.