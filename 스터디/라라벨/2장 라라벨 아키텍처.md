## 1. 라이프 사이클 (Request → Response)

### 1-1. 라라벨 애플리케이션 실행 흐름
![[Pasted image 20260217204243.png]]
**HTTP 요청 처리 파이프라인**
1. **엔트리 포인트(public/index.php)**
    - 모든 요청이 여기로 들어옴 (웹서버가 public을 document root로 두고 index.php로 라우팅)
2. **HTTP 커널(App\Http\Kernel / Illuminate\Foundation\Http\Kernel)**
    - 애플리케이션을 셋업하고, 미들웨어 파이프라인을 구성한 다음
    - Request를 **라우터로 디스패치**함
3. **라우터(routes/web.php, routes/api.php)**
    - 요청(URI/Method 등)에 맞는 라우트를 찾아서
        - 컨트롤러 메서드 / 액션(__invoke) / 클로저 중 무엇을 실행할지 결정
4. **미들웨어**
    - 요청 전처리/후처리를 체인으로 수행
        - 인증, 세션, 쿠키 암복호화 같은 “횡단 관심사”가 여기 있음
        - 최종적으로 컨트롤러 실행 전후를 감싸는 구조
5. **컨트롤러**
    - 비즈니스 로직 실행(보통 서비스/유스케이스로 위임)
    - 결과를 **Response/JsonResponse** 형태로 반환
6. **Response가 역순으로 돌아감**
    - 컨트롤러 → 미들웨어 → 라우터 → 커널 → 엔트리 포인트
    - index.php에서 `send()`로 실제 HTTP 응답을 전송하고 종료(`terminate()`)

Spring 의 DispatcherServlet 과 유사하게 FrontController 패턴이 적용되어 있다

---

### 1-2. 엔트리 포인트 (public/index.php) 핵심 4단계

```jsx
<?php

use Illuminate\\Contracts\\Http\\Kernel; // 인터페이스
use Illuminate\\Http\\Request;
// 1. 오토로더 로딩
define('LARAVEL_START', microtime(true));

/*
|--------------------------------------------------------------------------
| Check If The Application Is Under Maintenance
|--------------------------------------------------------------------------
|
| If the application is in maintenance / demo mode via the "down" command
| we will load this file so that any pre-rendered content can be shown
| instead of starting the framework, which could cause an exception.
|
*/

if (file_exists($maintenance = __DIR__.'/../storage/framework/maintenance.php')) {
    require $maintenance;
}

/*
|--------------------------------------------------------------------------
| Register The Auto Loader
|--------------------------------------------------------------------------
|
| Composer provides a convenient, automatically generated class loader for
| this application. We just need to utilize it! We'll simply require it
| into the script here so we don't need to manually load our classes.
|
*/

require __DIR__.'/../vendor/autoload.php';

/*
|--------------------------------------------------------------------------
| Run The Application
|--------------------------------------------------------------------------
|
| Once we have the application, we can handle the incoming request using
| the application's HTTP kernel. Then, we will send the response back
| to this client's browser, allowing them to enjoy our application.
|
*/
// 2. 프레임워크 실행
$app = require_once __DIR__.'/../bootstrap/app.php';
// 3. 애플리케이션 실행 및 HTTP 응답 송신
$kernel = $app->make(Kernel::class);
$response = $kernel->handle(
    $request = Request::capture()
)->send();
// 4. 종료 처리
$kernel->terminate($request, $response);
```

- (1) **Composer 오토로더 로딩**
- (2) `bootstrap/app.php` 로딩 → **Application(=서비스 컨테이너)** 생성
- (3) `$app->make(Kernel::class)` 로 **HTTP 커널 생성** 후 `handle()` 실행 → Response 획득 & send
- (4) `terminate()`로 종료 처리

---

### 1-3. HTTP 커널의 역할

- 핵심은 `handle()` 안에서
    - `sendRequestThroughRouter()`로 라우터 실행
    - 예외 발생 시 report/render 처리
    - `RequestHandled` 같은 이벤트 디스패치

> 실무 관점: “요청 처리의 프레임워크 레벨 관문”이 커널이고, 여기서 미들웨어/라우팅/예외/이벤트가 한 번에 엮인다.

---

### 1-4. 라우터

```jsx
<?php

use Illuminate\\Support\\Facades\\Route;

// 1. App\\Http\\Controllers\\TaskController 클래스의 getTasks 메서드를 실행
Route::get('/tasks', [App\\Http\\Controllers\\TaskController::class, 'getTasks']);
// 2. App\\Http\\Controllers\\AddTaskAction의 __invoke 메서드를 실행
Route::post('/tasks', 'App\\Http\\Controllers\\AddTaskAction');
// 3. 클로저를 실행
Route::get('/hello', function (Request $request) {
    return view('hello');
});
```

- 요청과 매칭되는 라우트를 찾아 실행
- 라우트 정의 방식
    - 컨트롤러 메서드 매핑
    - 액션 클래스(__invoke)
    - 클로저

---

### 1-5. 미들웨어

```jsx
<?php

namespace Illuminate\\Cookie\\Middleware;
...
class EncryptCookies
{
...
    public function handle($request, Closure $next)
    {
        // 1. decrypt 메서드로 암호화된 Cookie를 복호화해 Request를 얻음
        // 2. 다음 미들웨어를 실행해 Response를 얻음
        // 3. encrypt 메서드로 Response를 암호화함
        return $this->encrypt($next($this->decrypt($request)));
    }
...
}
```

- Request/Response의 전후에 끼워 넣는 체인 처리
- 대표 예: 쿠키 복호화 → 다음 처리 실행 → 응답 쿠키 암호화
- 여러 미들웨어를 조합해 확장/제거가 쉽다

---

### 1-6. 컨트롤러

- HTTP 요청에 대응하는 “엔드포인트 구현부”
- 보통 컨트롤러 내부에서 모든 걸 끝내지 않고
    - **서비스/유스케이스 레이어로 위임**하는 형태가 실무에 맞다
- 여기서 중요한 포인트: Request, Service 같은 의존성이 **서비스 컨테이너로 주입**될 수 있다는 점

---

## 2. 서비스 컨테이너 (IoC Container)

### 2-1. 서비스 컨테이너란?

- 프레임워크가 제공하는 수많은 클래스 인스턴스를 **생성/관리/캐싱**하는 “중앙 인스턴스 관리자”
- 개발자는 “new”로 직접 만들기보다 **컨테이너에게 요청(make/app)**해서 받는다
- 싱글톤이면 캐시된 인스턴스가 재사용된다

---

### 2-2. 바인드 vs 리졸브
![[Pasted image 20260217204323.png]]
- **바인드(bind)**: “이 이름(클래스/인터페이스)을 요청하면 이렇게 만들어줘” 등록
- **리졸브(resolve)**: 실제로 make/app로 요청해서 인스턴스를 얻는 것

```jsx
use Illuminate\\Foundation\\Application;
use Monolog\\Logger;
use Psr\\Log\\LoggerInterface;

class FooLogger
{
    protected $logger;

    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }
}

app()->bind(FooLogger::class, function (Application $app) { // 1
    $logger = new Logger('my_log');
    return new FooLogger($logger);
});

$foologger = app()->make(FooLogger::class); // 2
```

---

### 2-3. 바인드 메서드들 핵심 차이

- `bind`: 요청할 때마다 새로 생성
- `bindIf`: 없을 때만 bind (이미 있으면 무시)
- `singleton`: 최초 1회 생성 후 캐싱(재사용)
- `instance`: 이미 만들어 둔 인스턴스를 그대로 등록(재사용)

추가로 중요한 패턴:

- **인터페이스 → 구현체 매핑**을 컨테이너에 등록해두면
    
    코드가 구현체에 덜 묶이게 된다.
    

---

### 2-4. 리졸브 (make/app)

- `make()` 또는 `app()`로 인스턴스를 얻음
- 바인드가 없어도 **구상 클래스**면 컨테이너가 리플렉션으로 생성 가능
    - 단, 인터페이스/추상 클래스면 바인드가 필요

```jsx
app()->bind(Number::class, function () {
    return new Number();
});

$number1 = app()->make(Number::class);
$number2 = app(Number::class);
```

---

### 2-5. DI와 서비스 컨테이너

- **컨스트럭터 주입(CI)**: 생성자 타입힌트 기반 자동 주입
- **메서드 주입(MI)**: 컨테이너의 `call()`로 타입힌트 기반 주입
- **컨텍스트 바인딩(when/needs/give)**:
    - 같은 인터페이스라도 “어떤 클래스에서 쓰느냐”에 따라 구현체를 다르게 주입 가능

```jsx
class UserService
{
    protected $notifier;

    public function __construct(NotifierInterface $notifier)
    {
        $this->notifier = $notifier;
    }

    public function sendNotification(string $to, string $message): void
    {
        $this->notifier->send($to, $message);
    }
}

$user = app()->make(UserService::class);
$user->sendNotification('to', 'message');
```

---

### 2-6. 퍼사드(Facade)

- `Config::get()` 같은 정적 호출처럼 보이지만
- 실제론 `__callStatic`으로 **컨테이너에서 인스턴스 꺼내서 메서드 호출**하는 구조
- 장점: 편함
- 단점: 어디서든 호출 가능해서 **결합도가 강해질 수 있음**(운영 기간/규모가 크면 주의)

```jsx
$debug = Config::get('app.debug');

<?php

use Illuminate\\Support\\Facades\\Facade;
use Illuminate\\Support\\ServiceProvider;

return [
...
    'aliases' => Facade::defaultAliases()->merge([
        // 'Example' => App\\Facades\\Example::class,
    ])->toArray(),

];

public static function defaultAliases()
{
    return collect([
        'App' => App::class,
        'Arr' => Arr::class,
        'Artisan' => Artisan::class,
        'Auth' => Auth::class,
        'Blade' => Blade::class,
        'Broadcast' => Broadcast::class,
        'Bus' => Bus::class,
        'Cache' => Cache::class,
        'Config' => Config::class,
...
    ]);
}
```

---

## 3. 서비스 프로바이더 (Service Provider)

### 역할 요약

- 라라벨 부팅 과정에서 “프레임워크/앱 기능을 초기화”하는 진입점
- 주 역할
    - 컨테이너 바인드 등록
    - 이벤트/미들웨어/라우팅 등록
    - 외부 컴포넌트 통합

### 동작 순서

- 먼저 전체 프로바이더의 **register()**
- 그 다음 **boot()**
- 권장 관례
    - `register()` : 바인드 등록만
    - `boot()` : 다른 서비스가 이미 등록된 이후에 필요한 작업(의존 리졸브가 필요한 바인드 등)

### 지연 로딩(DeferrableProvider)

- 무조건 부팅 때 register하지 않고
- “특정 서비스가 리졸브되는 순간” 혹은 “특정 이벤트 발생 시점”에 등록되게 할 수 있음

---

## 4. 컨트랙트 (Contracts = 인터페이스)

### 4-1. 컨트랙트 기본

- 라라벨 코어 기능을 “인터페이스(계약)”로 정의한 것
- 코어 컴포넌트도 컨트랙트에 의존하도록 만들어져 있어서
- 구현체를 갈아끼울 수 있는 구조가 된다

---

### 4-2. 컨트랙트로 기능 대체 예시(암호화 교체)

- Encrypter 컨트랙트를 구현한 `BlowfishEncrypter`를 만들고
- 서비스 컨테이너의 `encrypter` 바인딩을 **앱 프로바이더에서 재바인드**
- 그러면 쿠키/CSRF 등 프레임워크 전반 암호화 동작이 교체됨

> 포인트: “컨트랙트에 맞춰 구현 + 컨테이너 바인딩 변경”만으로 프레임워크 레벨 기능을 교체할 수 있다.