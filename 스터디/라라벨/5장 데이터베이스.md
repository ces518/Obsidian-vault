## 1. 마이그레이션(Migration)

- **의미**: 테이블 생성/수정/삭제 같은 DB 스키마 변경을 **PHP 코드로 버전 관리**하는 기능.
- **장점**
    - CREATE/ALTER 같은 변경 이력을 **git 등으로 함께 관리**
    - 팀/환경이 달라도 동일한 스키마를 재현 가능
- **흐름**
    1. `php artisan make:migration ...` 로 마이그레이션 파일 생성
    2. `database/migrations`에 up/down 로직 작성
    3. `php artisan migrate`로 반영 / `rollback`, `reset` 등으로 원복
- **기본 구조**
    - `up()`: 스키마 적용(생성/변경)
    - `down()`: up의 내용을 되돌림(삭제/원복)
- **자주 쓰는 옵션**
    - `-create=테이블명`: 새 테이블 생성용 코드 템플릿
    - `-table=테이블명`: 기존 테이블 변경용
    - `-path=경로`: 파일 생성 위치 지정
- **Schema Builder (Schema + Blueprint)**
    - `Schema::create('table', function (Blueprint $table) { ... })`
    - 칼럼 타입 예: `id()`, `string()`, `text()`, `integer()`, `boolean()`, `date()`, `dateTime()`, `json()`, `timestamps()`, `softDeletes()`
    - 칼럼 속성 예: `nullable()`, `default()`, `unsigned()`, `after()`
    - 인덱스 예: `primary()`, `unique()`, `index()` / 삭제: `dropPrimary()`, `dropUnique()`, `dropIndex()`
- **실행 상태 관리**
    - 어떤 마이그레이션이 실행됐는지는 DB의 **migrations 테이블**에서 관리됨(파일명 + batch).

```jsx
// books 테이블 마이그레이션 샘플 코드
<?php

use Illuminate\\Database\\Migrations\\Migration;
use Illuminate\\Database\\Schema\\Blueprint;
use Illuminate\\Support\\Facades\\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('books', function (Blueprint $table) {
            $table->id();
            $table->string('name', '100');
            $table->integer('author_id');
            $table->integer('publisher_id');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('books');
    }
};
```

flyway 와 비슷한 기능.

---

## 2. 시더(Seeder)

- **의미**: 초기 데이터/테스트 데이터를 **코드로 삽입**하는 기능.
- **생성/실행**
    - `php artisan make:seeder XxxSeeder`
    - `DatabaseSeeder.php`의 `run()`에서 `$this->call(XxxSeeder::class);`
    - 실행: `php artisan db:seed`
- **DB 퍼사드로 직접 insert**
    - `DB::table('authors')->insert([...]);` 형태로 반복 삽입 가능

```jsx
<?php

namespace Database\\Seeders;

use Illuminate\\Database\\Seeder;
use Illuminate\\Support\\Facades\\DB;

class AuthorsTableSeeder extends Seeder
{
    /**
     * Run the database seeds.
     */
    public function run(): void
    {
        // Authors 테이블에 레코드를 10건 등록한다
        for ($i = 1; $i <= 10; $i++) {
            $author = [
                'name' => 'author' . $i,
                'created_at' => now(),
                'updated_at' => now(),
            ];
            DB::table('authors')->insert($author);
        }
    }
}
```

- **Faker로 더미 데이터 생성 (테스트 데이터 간단하게 생성해주는 표준)**
    - 라라벨 기본 포함(예: name, email, address 등)
    - Seeder `run(Faker $faker)` 형태로 받아서 `$faker->name` 같은 값 생성

```jsx
<?php

namespace Database\\Seeders;

use Faker\\Generator as Faker;
use Illuminate\\Database\\Seeder;
use Illuminate\\Support\\Facades\\DB;

class AuthorsTableSeeder extends Seeder
{
    /**
     * Run the database seeds.
     */
    public function run(Faker $faker): void
    {
        // Faker를 사용해 Authors 테이블에 레코드를 10건 등록한다
        for ($i = 1; $i <= 10; $i++) {
            $author = [
                'name' => $faker->name,
                'created_at' => now(),
                'updated_at' => now(),
            ];
            DB::table('authors')->insert($author);
        }
    }
}
```

- **Factory로 대량 생성**
    - `make:factory`로 모델별 데이터 생성 규칙 정의
    - 예: `Publisher::factory(50)->create();` 처럼 간단히 대량 삽입

---

## 3. Eloquent(ORM)

```jsx
$ php artisan make:model (클래스명) // artisan 명령어로 생성

<?php

namespace App\\Models;

use Illuminate\\Database\\Eloquent\\Factories\\HasFactory;
use Illuminate\\Database\\Eloquent\\Model;

class Author extends Model
{
    use HasFactory;
}
```

- **의미**: 라라벨의 대표 ORM. **테이블 ↔ 모델 클래스**를 연결해 직관적으로 CRUD.
- **규약(Convention)**
    - 모델: 단수형(Author) / 테이블: 복수형(authors)
    - 규약 미사용 시 `protected $table = '...'` 로 지정 가능
- **주요 속성**
    - `$primaryKey`: 기본 키 칼럼명 변경
    - `$timestamps = false`: created_at/updated_at 자동 기록 비활성화
    - **Mass Assignment 방어**
        - 대량 할당 취약성 대책
        - `$fillable`: 수정 허용 칼럼(화이트리스트)
        - `$guarded`: 수정 금지 칼럼(블랙리스트)
        - _둘을 동시에 쓰지 않음_

```jsx
<?php

namespace App\\Models;

use Illuminate\\Database\\Eloquent\\Factories\\HasFactory;
use Illuminate\\Database\\Eloquent\\Model;

class Author extends Model
{
    // name 칼럼은 수정할 수 있도록 한다
    protected $fillable = [
        'name',
    ];
...
```

- **기본 CRUD**
    - 조회: `all()`, `find()`, `findOrFail()`, `whereXxx()->get()`
    - 생성: `create([...])`, 또는 인스턴스 후 `save()`
    - 수정: `update([...])` / 속성 변경 후 `save()`
    - 삭제: `delete()`, `destroy(id|[])`
- **쿼리 빌더식 조작(체인)**
    - `where`, `orWhere`, `orderBy` 등 조합

```jsx
// authors 테이블에서 id가 1 또는 2인 레코드를 얻는다
$authors = \\App\\Models\\Author::where('id', 1)->orWhere('id', 2)->get();

// authors 테이블에서 id가 5 이상인 레코드를 id 순으로 얻는다
$authors = \\App\\Models\\Author::where('id', '>=', 5)
            ->orderBy('id')
            ->get();
```

- **JSON 변환**
    - `toJson()`으로 결과를 JSON 응답에 활용 가능
- **Accessor / Mutator**
    - `getNameAttribute`, `setNameAttribute` 같은 메서드로 조회/저장 시 값 가공 가능
- **없으면 생성**
    - `firstOrCreate`, `firstOrNew` 패턴으로 “없을 때만 등록”
- **소프트 삭제(논리 삭제)**
    - 마이그레이션에 `softDeletes()`로 `deleted_at` 추가
    - 모델에 `use SoftDeletes;`
    - 포함 조회: `withTrashed()`, 삭제만: `onlyTrashed()`
- **릴레이션(Relationship)**
    - 1:1 `hasOne`, `belongsTo`
    - 1 `hasMany`
    - 예: `$author->books`, `$book->detail` 처럼 객체 탐색형 접근
- **SQL 확인**
    - `toSql()`로 생성된 SQL 확인(실행 전 형태)
    - 실제 실행 로그는 `DB::enableQueryLog()` + `DB::getQueryLog()`

---

## 4. 쿼리 빌더(Query Builder)

- **의미**: 메서드 체인으로 SQL을 조립하는 방식(Eloquent도 내부적으로 활용).
- **얻는 방법**
    - `DB::table('books')`
    - 또는 `DatabaseManager -> connection() -> table()`
- **주요 메서드**
    - 선택: `select`, `selectRaw`
    - 조건: `where`, `whereBetween`, `whereIn`, `whereNull` 등
    - 페이징/범위: `limit/take`, `offset/skip`
    - 정렬/집계: `orderBy`, `groupBy`, `having`, `havingRaw`
    - 조인: `join`, `leftJoin`, `rightJoin`
    - 실행: `get()`(여러 행), `first()`(1행), `count/max/min/avg`
    - 변경: `insert`, `update`, `delete`, `truncate`

---

## 5. 트랜잭션 & 락

- **트랜잭션**
    - 수동: `DB::beginTransaction()`, `commit()`, `rollback()`
    - 자동: `DB::transaction(function(){ ... })`
- **테이블/행 락**
    - `sharedLock()`(공유 락), `lockForUpdate()`(배타 락)

---

## 6. Raw SQL 실행

- **DB 퍼사드로 직접 SQL 실행**
    - `DB::select/insert/update/delete/statement(SQL, bindings)`
- **PDO 직접 사용도 가능**
    - `DB::connection()->getPdo()`로 prepare/execute
- **메모**
    - Raw SQL / PDO는 성능상 유리할 때가 있지만, 가독성/유지보수성과 트레이드오프

---

## 7. 리포지터리 패턴(Repository Pattern)

- **목적**: 비즈니스 로직(Service)에서 DB 접근(Eloquent 등)을 직접 호출하지 않게 해서
    
    **결합도를 낮추고 테스트/교체를 쉽게** 만들기.
    
- **구성**
    
    1. `PublisherRepositoryInterface` 같은 **인터페이스** 정의(예: `findByName`, `store`)
    2. 비즈니스에서 쓸 **Entity(Publisher)** 정의
    3. 실제 DB 접근 구현체(예: `PublisherRepository`)에서 Eloquent로 조작
    4. Service는 구현체가 아니라 **인터페이스에 의존**
    5. ServiceProvider에서 `bind(Interface::class, Impl::class)`로 연결
- **효과**
    
    - MySQL/Eloquent가 아니더라도, 구현체만 바꿔 끼워 서비스 로직 변경 최소화
- **주의**
    
    - 클래스 수가 늘어 **작은 규모/단기 프로젝트엔 과할 수 있음**

---