## 1. MVC와 ADR

### 1-1. MVC 기본

- *MVC(Model–View–Controller)**는 원래 UI 설계 패턴이고, 책임을 3개로 나눠 복잡도를 낮추는 방식.
- **Model**: 비즈니스 로직(현실적으로는 “도메인 + 데이터 접근”까지 섞이기 쉬움)
- **View**: 화면/응답 출력(HTML, JSON 등 “표현”)
- **Controller**: 요청을 받아 흐름을 조율하고 응답으로 연결
![[Pasted image 20260217210244.png]]
### MVC와 라라벨 매핑

라라벨은 MVC를 강제하진 않지만, MVC 스타일을 쉽게 쓰게 해주는 구성요소를 제공:

- **Router**: 컨트롤러 실행을 연결/디스패치
- **Blade**: HTML 출력(템플릿)
- **Eloquent/QueryBuilder**: DB 접근(모델 쪽 도구)
![[Pasted image 20260217210256.png]]
✅ 중요한 주의점

**MVC = 디렉터리 구조가 아니다.**

`Controller/Model/View`라는 폴더가 아니라, **“책임 분리”가 본질**이고 이름/위치가 달라도 된다.

---

### 라라벨의 Controller

- 컨트롤러는 “URL에 대응하는 액션 메서드 집합”
- 리소스 컨트롤러(CRUD 형태)는 **프레임워크가 제공하는 개발 템플릿**일 뿐 “정답 구조”는 아님
- 라우팅에서 클래스만 지정하면 `__invoke` 같은 단일 액션도 가능 → MVC를 더 잘게 쪼갤 수도 있음

---

### 라라벨의 Model 관점

일반적으로 웹앱의 “모델”은 실제로:

- **비즈니스 로직 계층**
    
- **데이터베이스 조작 계층**
    
    이 두 개가 섞여 있는 경우가 많고, 라라벨에서는 Eloquent 때문에 더 쉽게 합쳐짐.
    

### 대표적인 안티패턴 2개

- **Fat Model**: Eloquent 모델 안에 DB처리 + 비즈니스 로직이 계속 붙어서 모델이 비대해짐
- **Fat Controller**: 컨트롤러가 서비스 호출, 예외처리, 외부 연동, 검증, 트랜잭션까지 다 떠안음

➡️ 결과: 클래스가 커지고 결합도가 올라가며 리팩터링/테스트가 어려워짐

---

### 모델 구현 방식 2가지 비교

### (1) 트랜잭션 스크립트 패턴 (Transaction Script)

- “서적 구매” 같은 **하나의 유스케이스 흐름을 한 클래스/메서드에 모아** 구현
- 장점: 단순하고 빠르게 만들기 좋음
- 단점: 규모가 커지면 비슷한 흐름이 늘고, 공통화/재사용이 꼬이고, 클래스들이 뒤섞여 유지보수 난이도가 급상승

> 핵심 메시지: “개발하기 편한 구조”가 아니라 **“비즈니스 문제 해결 중심”**으로 설계해야 한다.

### (2) 도메인 모델 패턴 (Domain Model) / DDD 지향

- 비즈니스 개념을 모델링하고(용어/개념/관계/그림)
- 이해관계자와 합의된 모델을 코드로 반영
- 장점: 복잡한 도메인 변화에 강함
- 단점: 모델링 역량이 필요하고 난이도가 높음(초기 비용↑)

---

### 라라벨의 View

- Blade 템플릿을 “뷰”로 볼 수 있지만,
- 실제 HTTP 응답은 결국 `Illuminate\\Http\\Response`를 통해 나감
- 그래서 “템플릿만”이 아니라 **상태코드/헤더/쿠키 등 응답 자체**를 다루려면 Response 레벨의 설계가 필요

```jsx
<?php

declare(strict_types=1);

namespace App\\Http\\Controllers;

use Illuminate\\Http\\Response;
use Illuminate\\View\\View;

final class UserController extends Controller
{
    public function detail(string $id): View
    {
        return view('user.detail');
    }
    
    public function userDetail(string $id): Response
    {
        return new Response(view('user.detail'), Response::HTTP_OK);
    }
}
```

---

## 1-2. ADR 패턴
![[Pasted image 20260217210334.png]]
- *ADR(Action–Domain–Responder)**는 MVC를 서버사이드 요청/응답에 맞게 더 구체화한 패턴.

MVC2와 비슷한 방향이지만, 책임을 더 명확히 찢어놨다고 보면 됨.

### 구성요소 역할

- **Action**: HTTP 요청을 받아 Domain 호출 → 결과를 Responder로 넘김 (연결자)
- **Domain**: 비즈니스 로직의 진입점(유스케이스/서비스/도메인 모델 등)
- **Responder**: Domain 결과를 **HTTP 응답으로 변환**(상태코드, 헤더, 쿠키, 템플릿/JSON 변환)

### ADR이 해결하려는 문제 (왜 필요한가)

MVC 컨트롤러는 보통 “여러 액션 메서드”를 포함하고,

사양이 바뀔 때마다 컨트롤러 생성자 의존성이 늘고 메서드에 로직이 계속 붙음 → 컨트롤러가 비대해짐.

ADR은:

- **URI 1개 = Action 클래스 1개**
- Action은 최대한 얇게(요청 파싱/도메인 호출/리스폰더 위임)
- 응답 구성은 Responder로 분리

➡️ “클래스 수가 늘어나는 것”은 단점이 아니라

**작은 책임들이 정리된 집합**이 되는 것.

---

## 2. 아키텍처 다루기

### 2-1. 프레임워크와 아키텍처

- 라라벨은 “어떤 아키텍처든” 얹을 수 있게 해주는 유연성이 있음
- 특히 **서비스 컨테이너/서비스 프로바이더** 덕분에
    - 구현 교체
        
    - 계층 분리
        
    - 의존성 주입
        
        같은 패턴을 쉽게 구성 가능
        

---

### 2-2. 아키텍처 설계 포인트

- 팀 규모/기간/운영 요구 등 현실적 제약 속에서 타협점을 잡아야 함
- 요구사항을 2개로 나눠서 봐야 함
    - **기능 요구사항**: 비즈니스 동작
    - **비기능 요구사항**: 성능/확장/보안/운영 편의 등
- 특히 핵심 메시지:
    - **비즈니스 로직에서 DB 조작을 분리하는 게 중요**

---

### 2-3. 레이어드 아키텍처 (계층화)

MVC를 쓴다고 해도, 현실에서는 컨트롤러에 DB 접근이 직접 들어가거나,

특정 클래스가 너무 많은 책임을 갖는 문제가 생김.

레이어드의 목적은 단순 “깔끔함”이 아니라:

- **상위 계층 → 하위 계층 단방향 의존**
- 비즈니스 로직 레이어에서 **비기능 요구사항/외부 의존을 제거**
- 영향 범위를 줄이고 테스트/변경 대응력을 높이는 것

### 계층화 개념 1) 모델과 컨트롤러 분리

- 컨트롤러가 DB를 직접 만지지 않게
- 비즈니스 로직을 **Service 클래스로 분리**
- 컨트롤러는 서비스만 호출하고 결과를 뷰로 전달

### 계층화 개념 2) 서비스 계층과 DB 분리 (Repository)

- 서비스가 여전히 Eloquent/DB에 의존하면 변경에 약함
- 그래서 DB조작을 **Repository 인터페이스**로 추상화
- 구현체를 바꿔도(다른 DB/외부 API/캐시 등) 서비스는 영향 최소화
- 이 매핑은 **서비스 프로바이더에서 바인딩**으로 해결

---

### 2-4. 레이어드 이후의 세계

- 계층화는 “비즈니스 로직 레이어를 얇게” 만드는 것뿐 아니라
- 비즈니스 로직에서 비기능 요구사항을 제거해 **복잡도 폭발을 막는 게 목적**
- 하지만 더 복잡해지면 레이어드만으론 부족하고
    - **DDD(도메인 지식 + 패턴 조합)** 같은 접근이 필요해질 수 있음