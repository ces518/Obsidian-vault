# 개요

- 모바일/온라인 게임에서 **토너먼트 기간 동안의 점수로 순위를 매기는 리더보드**
    
- 화면에는 보통
    
    - **상위 Top N(예: 10명)**
        
    - **내 순위(특정 사용자 1명)**
        
    - (확장) **내 주변 ±4명** 같은 “이웃 순위”
        
        를 함께 보여준다. (페이지 예시도 “상위 10 + 특정 사용자 + 주변 사용자” 요구)
        
- **매달 새 토너먼트 시작 → 새 리더보드 생성**
    
- 즉, 리더보드는 “월 단위로 롤오버” 되는 구조를 전제
    
- **DAU 500만**, **MAU 2,500만** 가정
    
- 각 선수는 하루 평균 **10경기**
    
    - 대략적으로 “점수 증가 이벤트”가 DAU 기준으로는 **하루 5,000만 번(= 500만 × 10)** 정도 발생한다고 볼 수 있음(단, 승리만 점수면 승률에 따라 실제는 더 줄 수 있음).
- 결과는 **실시간 또는 실시간에 가깝게** 보여야 함
    
- **누적 히스토리(과거 기록 나열)** 는 중요하지 않음(바람직하지 않다고 명시)
---
# 요구사항

## 기능 요구사항

1. 전체 사용자 대상 순위 관리
    1. 모든 플레이어는 순위표에 포함 되어야 함
    2. 점수 = 경기 승리시 + 1점
2. 리더보드 조회 기능
    1. Top N 조회 (상위 10명)
    2. 특정 사용자 순위 조회 (현재 로그인 유저 순위)
    3. 주변 순위 조회 (특정 사용자 기준 +- 4명)
## 비기능 요구사항

- 점수 업데이트는 실시간 또는 Near Real-Time 으로 반영 되어야 함
    - Event Sourcing 보다는 **Latest State Snapshot 기반 Read Model**이 핵심
- 높은 가용성 (HA)
- 확장성 (Scalability)
- 낮은 지연시간 (Low Latency)

## 개략적 규모 측정

|항목|값|
|---|---|
|DAU|5,000,000|
|MAU|25,000,000|
|1인당 평균 경기 수|10회/일|

### 동시 플레이어 수 측정

24시간 균등 분포 가정:

```jsx
5,000,000 / 100,000초 ≈ 50명/sec
```

피크 트래픽 (x5) 가정:

```jsx
≈ 250명/sec
```

### 점수 업데이트 QPS

```jsx
평균: 50명 × 10경기 ≈ 500 QPS
피크: 500 × 5 ≈ 2,500 QPS
```

### Top 10 조회 QPS

각 사용자가 하루 한 번 게임 접속 가정:

```jsx
≈ 50 QPS
```

---

# 개략적 설계안
## 시스템 구성요소

크게 2개의 서비스로 분리됨

|서비스|역할|
|---|---|
|Game Service|게임 로직 처리 (승패 판단)|
|Leaderboard Service|점수 저장 및 순위 계산|
![](Pasted%20image%2020260222160138%201.png)

```jsx
1. Client → Game Service 요청
2. Game Service:
      - 승리 유효성 검증
      - 치팅 여부 확인
3. Game Service → Leaderboard Service
      점수 갱신 요청
4. Leaderboard Service:
      - 점수 업데이트
      - 순위 재정렬
```

## Client → Leaderboard 직접 호출을 막아야 하는 이유?
보안이슈.

만약 클라이언트가 직접 점수를 올릴 수 있으면:

- 프록시 설치
- API 변조
- 점수 위조
- MITM(중간 공격자) 공격

같은 방식으로 점수를 조작할 수 있음
![](Pasted%20image%2020260222160244.png)
## 데이터 모델

- 리더보드는 **월 단위로 하나의 데이터셋**(이번 달 리더보드)로 관리
- 가장 단순한 모델은 결국:
    - **user_id → score**
    - 그리고 score 기준 정렬/순위 계산

### 1. 관계형 DB 모델

**테이블 스키마(가장 단순형)**

- `leaderboard(user_id VARCHAR, score INT)`
- 실제 서비스라면 `game_id`, `timestamp` 같은 컬럼이 더 붙을 수 있지만, **“순위 질의/갱신 로직”은 동일**하다고 설명

**점수 갱신(write)**

- 신규 유저: `INSERT ... score=1`
- 기존 유저: `UPDATE leaderboard SET score = score + 1 WHERE user_id=...`

**순위 조회(read)**

- 점수 내림차순 정렬 후 랭크 매김(예: rownum)
    - `ORDER BY score DESC` 기반

**한계점**

- 레코드가 **수백만 단위**가 되면,
    - 순위를 매기려면 사실상 “전체를 정렬/스캔”해야 해서 **수십 초** 걸릴 수 있음 → **실시간 리더보드에 부적합**
- 데이터가 계속 변하므로 **캐시로도 해결이 안 됨**
- `LIMIT 10` + index로 Top-N 최적화는 가능하지만,
    - **특정 사용자의 순위**(Top 밖 유저)는 여전히 전체를 훑는 문제가 남음
    - 즉, “Top-N만 빠른” 편법이지, 요구사항(특정 유저/주변 순위)엔 약함
### 2. Redis 모델 (Sorted Set)

**자료구조 선택: Sorted Set(ZSET)**

- ZSET은 각 원소(member)가 **score를 가지고**,
- score 기준으로 자동 정렬되는 집합(원소는 고유, score는 중복 가능)

**리더보드를 ZSET으로 표현**

- “월별 리더보드”를 키로 둠:
    - 예: `leaderboard_feb_2021` 같은 형태(책 예시)
- 내부적으로는 **“점수 + 사용자” 테이블처럼 생각**하면 이해가 쉽다고 설명
    - score 내림차순으로 정렬된 상태

**ZSET이 적절한 이유?**

- 레디스는 메모리 기반이라 **읽기/쓰기 빠름**
- ZSET은 리더보드에서 필요한 작업을 “복잡한 SQL 없이” 지원하기 좋음
- ZSET은 내부적으로
    - **해시 테이블**(user→score 저장)
        
    - **스킵 리스트**(score 기반 정렬/범위 탐색)
        
        를 같이 써서 **예측 가능한 성능**을 낼 수 있다
![](Pasted%20image%2020260222160717.png)
## 저장소 요구사항

### 1) 최소 저장해야 하는 데이터

- **user_id (사용자 ID)**
    
- **score (점수)**
    
    → 리더보드의 본질은 “유저별 누적 점수”라서 이 두 개는 필수.
    

### 2) 용량 산정의 기준

- **MAU 2,500만 명 전원이** 해당 월에 **최소 1번 이상 승리**
- 그러면 **월 순위표 항목 수 = 2,500만 개**(유저당 1개 엔트리)

### 3) 메모리 용량 계산(레디스 캐시 기준)

가정:

- user_id: **24자 문자열**
- score: **16-bit 정수(2바이트)**

엔트리 1개당:

- 24B + 2B = **26B**

총 필요 메모리(최악 시나리오):

- **26B × 25,000,000 = 650,000,000B ≈ 650MB**

여기에

- 스킵 리스트 오버헤드 + 정렬 집합 해시 구조 오버헤드 등을 고려해서
- “메모리 사용량을 2배”로 잡아도

**대략 1.3GB 수준**

→ “요즘 레디스 서버 1대로도 충분히 수용 가능”이라고 결론.
### 4) CPU / I/O 관점(처리량)

앞서 추정한 최대 갱신 QPS가:

- **약 2,500 updates/sec**

-> **단일 레디스 서버로 감당 가능**한 수준이라고 판단.

### 5) 영속성(Persistence)

- 레디스 노드도 장애가 날 수 있음 → **데이터가 날아갈 위험**
- 레디스는 디스크 영속화 옵션(AOF/RDB)을 지원하지만,
    - “대규모 인스턴스를 디스크에서 읽어서 재시작”하는 데 시간이 많이 걸림

실무적 권장 구성:

- **레디스 Read Replica(읽기 사본)를 둔다**
- 주 서버 장애 시:
    - Replica를 **승격(promote)** 해서 주 서버로 전환
    - 그리고 **새 Replica를 다시 붙인다**

->  즉, “내구성은 디스크로만 해결하려 하지 말고, 복제 + 승격으로 운영 안정성을 확보”라는 메시지.

### 6) RDB(MySQL) 활용 포인트

레디스만 쓰면 “장애 시 복구 근거 데이터”가 약하니,

- **MySQL에 사용자/점수(및 승리 시각 timestamp)** 를 저장해두면
    - 경연 기록 같은 부가 기능에도 쓸 수 있고
    - **레디스 리더보드 복구**에도 활용 가능하다
---
# 레디스 규모 확장

**DAU 500만** 정도면 **레디스 캐시 서버 1대**로도 충분히 지원 가능

## **5억 DAU (기존 100배) 시 문제**

- 최악 저장 용량: **65GB** (기존 650MB × 100)
- 처리해야 할 QPS: **250,000 QPS** (기존 2,500 × 100)
- 이 정도면 **단일 레디스 인스턴스는 한계 → 샤딩 필요**

## 데이터 샤딩 방안

### A. 고정 파티션(Fixed Partition) — “점수 범위로 샤딩”

- 점수 범위를 예로 **1~1000**이라고 하면
    - 샤드 10개를 두고
    - 각 샤드가 **100점 구간** 담당 (예: 1~100, 101~200, …, 901~1000)
- 전제/주의:
    - 점수가 특정 구간에 몰리면 핫샤드가 생김 → **범위 조정 필요**
    - 본 설계에서는 **애플리케이션이 샤딩 라우팅 주체**라고 가정

**업데이트/조회 시 고려사항**

- 어떤 유저를 갱신하려면 **그 유저가 어느 샤드에 있는지 알아야 함**
    - 방법1: MySQL로 현재 점수 조회해서 샤드 결정
    - 방법2(권장): **user_id → shard(또는 점수)** 를 들고 있는 **2차 캐시**로 더 빠르게 찾기
- 유저 점수가 올라 **다른 샤드 범위로 이동**하면:
    - **기존 샤드에서 제거 후 새 샤드로 이동** 필요

**질의가 쉬운 이유**

- **Top 10**: “가장 높은 점수 범위 샤드”에서만 뽑으면 됨
    
    (예: 901~1000 샤드에서 Top 10)
    
- **특정 유저 순위**:
    
    - “해당 유저 샤드 내 순위” + “상위 점수 샤드들의 전체 사용자 수 합” 필요
    - 각 샤드의 사용자 수는 `INFO keyspace`로 **O(1)** 에 얻을 수 있다고 언급
### B. 해시 파티션(Hash Partition) — “Redis Cluster / 해시 슬롯”

- Redis Cluster는 키를 **16384 해시 슬롯**에 매핑:
    - `CRC16(key) % 16384`
- 장점:
    - 노드 추가/제거 시 **전체 키 재분배 없이** 운영이 비교적 쉬움
    - 점수 갱신은 “해당 키가 속한 샤드”에서만 하면 됨

**하지만 리더보드에선 단점이 큼**

- **Top 10**을 구하려면:
    - 모든 샤드에서 Top 10을 가져와서
    - 앱에서 다시 합쳐 정렬하는 **scatter-gather** 필요 (병렬화 가능)
- 문제점:
    - k가 커지면 각 샤드에서 많이 읽고 정렬해야 해서 지연 증가
    - **가장 느린 샤드가 전체 지연을 결정**(tail latency)
    - **특정 유저의 “전체 순위”를 간단히 계산할 방법이 없음**

<aside> 💡

**해시 파티션보다 고정 파티션이 리더보드에 더 적합** 하다고 결론.

</aside>
## 레디스 노드 크기 조정

- **쓰기 작업이 많은 애플리케이션은 메모리를 많이 잡아야 한다.**
- 이유: 장애 대비용으로 **스냅샷(백업)을 만들 때**도
    - 서비스는 계속 쓰기를 받아야 하고
    - 그 쓰기 연산을 **버퍼링/복사(COW 등)로 감당**해야 하기 때문.
- 그래서 책에서는 실무 팁으로:
    - **쓰기 많은 시스템이면 메모리를 2배 더 할당하는 것이 안전** 하다고 권장함.

---
# NoSQL

- Redis + MySQL 조합 말고 **NoSQL 하나로 단순화**할 수도 있다.
- 이상적인 NoSQL 후보 조건은:
    - **쓰기 연산에 최적화**
    - **같은 파티션 내에서 점수 기준 정렬이 효율적**
- DynamoDB, Cassandra, MongoDB 등

## DynamoDB

- **완전 관리형(fully managed)** 이고,
- **안정적인 성능 + 뛰어난 확장성**을 제공.
- 기본 키 외 속성으로 질의할 수 있게 **GSI(Global Secondary Index)**를 제공.
    - GSI는 **부모 테이블의 속성들로 구성**되지만, **기본 키는 부모 테이블과 다를 수 있음**(즉, 다른 접근 패턴을 위한 인덱스).

## 1차 설계

- **순위표 + 사용자 테이블을 비정규화**해서
    - 리더보드 화면에 필요한 정보를 한 테이블에 담는다.
- 예시 컬럼:
    - `user_id`, `score`, `email`, `profile_pic`, `leaderboard_name` 등

### 문제점

- 이렇게만 하면 레코드가 늘어날수록
    - 상위 점수를 찾기 위해 **테이블 전체를 스캔**해야 해서
    - 사용자가 많아지면 성능이 급격히 떨어짐.

## 2차 설계

파티션 키 + 정렬 키로 “월별 리더보드” 만들기

- **파티션 키(PK):** `game_name#{year-month}`
- **정렬 키(sort key):** `score`
- 이렇게 하면 “특정 월/게임 리더보드” 안에서 **점수 정렬 기반 조회**가 가능해지고,
    - 전체 테이블 스캔을 피할 수 있다.

### DynamoDB에서 터지는 핵심 이슈: 핫 파티션

- DynamoDB는 **(안정 해시 기반으로) 파티션 키에 따라 노드를 선택**해 저장한다.
- 그런데 PK를 `game_name#{year-month}`로 두면
    - “가장 최근 한 달 데이터”가 **한 파티션 키에 몰림**
    - 결과적으로 **핫 파티션(hot partition)** 발생

### 쓰기 샤딩(Write Sharding)

- PK 뒤에 파티션 번호를 붙여서 분산:
    - `game_name#{year-month}#p{partition_number}`
    - partition_number 예: `user_id % number_of_partitions`
- 이렇게 하면 같은 달 데이터가 **n개 파티션으로 분산**되어 핫 파티션을 완화.

### 파티션 수 선정

- 기준: **쓰기 볼륨 또는 DAU**
- 하지만:
    - 파티션이 많을수록 **각 파티션 부하는 감소**
    - 대신 특정 월 데이터를 읽을 때 **모든 파티션 결과를 합쳐야** 하므로 **읽기 복잡도는 증가**
- 결국 **부하 vs 복잡도 사이의 타협**이 필요.

### 백분위 대안

- 샤딩(특히 해시/쓰기 샤딩) 구조에서는
    - 사용자의 **정확한 상대적 순위(예: 1,200,001위)** 를 쉽게 구하기 어렵다.
- 대신 규모가 큰 경우엔
    - “상위 10~20%” 같은 **백분위(퍼센타일)** 로 보여주는 게 더 나을 수도 있다고 제안.
- 이를 위해:
    - 각 샤드의 **점수 분포를 분석해서 캐시**하는 크론잡을 둘 수 있음
    - 예: “10퍼센타일은 점수 < 100” 같은 형태로 경계값을 미리 만들어둠

## 결론

- NoSQL(DynamoDB)로도 가능하지만,
    - “월별 리더보드 PK”는 **핫 파티션**을 만들기 쉽고
    - 해결하려면 **쓰기 샤딩 + 분산-수집**으로 가야 해서 **복잡도가 크게 증가**
- 그래서 책의 전체 흐름상 “대안”으로 제시되며,
    - 여전히 **Redis ZSET이 리더보드 문제에 가장 직관적**인 선택지로 남는다.
---
