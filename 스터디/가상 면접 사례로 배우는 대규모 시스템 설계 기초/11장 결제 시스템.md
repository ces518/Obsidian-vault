# 개요

- **아마존닷컴 같은 전자상거래 서비스의 “결제 백엔드”**
    
- 고객 주문 시 **돈의 흐름**에 관련된 전 과정을 다룸
    
    (결제 승인/실패/정산, 내부 서비스 연동, 장애/재시도/일관성 등)
    
- 결제 시스템은 “금전적 가치 이전을 통해 금융 거래를 정산하는 모든 시스템”
    
- 겉으로 단순해 보여도,
    
    - **작은 실수 → 매출 손실**
        
    - **신뢰 붕괴(클레임/환불/정산 오류)**
        
        때문에 **정확성, 안정성, 감사 가능성**이 엄청 중요
---
# 요구사항

- **신용카드 처리 방식**
    
    - 카드 결제를 직접 구현하지 않고,
    - **PSP(결제 서비스 업체: Stripe/Braintree/Square 등)를 사용**한다고 가정
- **민감 정보 저장 정책**
    
    - **카드 번호를 시스템에 직접 저장하지 않음**
    - 보안/법규 준수 요건이 매우 까다로워서
    - **민감 데이터 처리는 PSP에 의존** (토큰화/결제수단 보관 등은 외부 위임)
- **글로벌/통화 범위**
    
    - 전 세계 사용을 전제하지만,
        
    - 면접 동안에는 **단일 통화만 사용**한다고 가정
        
        (다중 통화/환전/국제결제 복잡도는 범위 밖)
        
- **트래픽 가정**
    
    - **하루 100만 건 결제**
    - TPS 10
    - 일반적인 DB 로 충분히 처리 가능하므로, **정확한 처리**에 초점을 맞춰야함
- **정산/지급 요구사항**
    
    - 전자상거래 특성상 **판매자에게 매월 대금 지급(정산/지급) 절차**도 지원해야 함
- **연동/장애 전파 관련 주의사항(핵심 비기능 포인트)**
    
    - 결제 시스템은 **내부 서비스(계정/분석 등)** + **외부 서비스(PSP)** 와 연동
    - 따라서 **어떤 한 서비스 장애가 전체로 전파되지 않게**(격리/복원력) 고려해야 함
---
# 개략적 설계

결제 흐름은 **자금의 흐름**을 반영하기 위해 크게 두 단계로 쪼갬.

- **대금 수신 흐름 (pay-in)**
    
    구매자가 결제 → 플랫폼(아마존)의 은행계좌로 돈이 들어옴
    
    단, 그 돈의 소유권이 전부 플랫폼 것이 아니라 **판매자 몫이 큼**(플랫폼은 수수료 + 자금 관리자 역할)
    
- **대금 정산 흐름 (pay-out)**
    
    배송 등 조건이 충족된 뒤, 계좌에 묶여 있던 판매대금에서 **수수료를 제외한 금액**을 판매자 계좌로 송금
![[Pasted image 20260221184428.png]]
---
# 대금 수신 흐름
![[Pasted image 20260221184500.png]]
### 구성요소

1. 결제 서비스
    - 사용자로부터 **결제 이벤트(payment event)** 를 받고 전체 프로세스를 **조율(orchestrate)** 하는 중심
    - 보통 결제 처리 전에 가장 먼저 하는 건 **리스크 점검(risk check)**
        - AML/CFT 같은 규정 준수 여부
        - 자금세탁/테러자금조달 징후 평가
        - 실제로는 복잡해서 **외부 전문 업체**를 쓰는 경우가 많다고 전제
2. 결제 실행자
    - **PSP를 통해 “결제 주문(payment order)”을 실제로 실행**하는 역할
    - 포인트: **“1개의 결제 이벤트”에 여러 결제 주문이 포함될 수 있음**
        - 예: 한 번 결제로 여러 판매자의 상품을 같이 결제 → 주문을 판매자 단위로 쪼개서 여러 payment order로 처리
3. 결제 서비스 공급자
    - A 계정에서 B 계정으로 돈을 옮기는 “실제 결제 처리” 담당
    - 이 예시에선 **구매자의 신용카드 계좌에서 인출**하는 역할
4. 카드사
    - Visa/Mastercard/Discover 등 카드 생태계(복잡) 구성요소
    - **외부 영역**으로 간주
5. 지갑
    - 판매자(merchant)의 **잔액(balance)** 을 기록하는 시스템
    - “어떤 판매자에게 얼마가 쌓였는지” 같은 **정산의 기반 데이터**가 됨
6. 원장
    - 결제 트랜잭션에 대한 **금융 기록(회계성 기록)**
        
        예: “사용자에서 1달러 인출 / 판매자에게 1달러 지급” 같은 형태로 남김
        
    - 결제 후 분석(post-payment analysis), 수익 계산/예측에도 중요
        

### pay-in 플로우

1. 사용자가 **‘주문하기’** 클릭 → **결제 이벤트 생성** → 결제 서비스로 전송
2. 결제 서비스가 **결제 이벤트를 DB에 저장**
3. 결제 이벤트에 여러 결제 주문이 있을 수 있어, 주문 단위로 **결제 실행자 호출**
4. 결제 실행자가 **결제 주문을 DB에 저장**
5. 결제 실행자가 **외부 PSP 호출**해 카드 결제 처리
6. 결제 성공 후 결제 서비스가 **지갑 갱신(판매자 잔고 반영)**
7. 지갑 서버가 **갱신된 잔고를 DB에 저장**
8. 지갑 갱신이 성공하면 결제 서비스가 **원장 호출**
9. 원장 서비스가 **원장 정보를 DB에 추가**

> [!note]
> “외부 결제 성공”만으로 끝내지 않고, 내부적으로 **Wallet과 Ledger를 순서대로 갱신**해서 나중에 pay-out/대사/정산까지 이어질 기반을 만듦

## 결제 서비스 데이터 모델
#### 저장소 관점

결제 시스템에서 DB 고를 때 성능이 1순위가 아니다. 대신 아래를 더 중요하게 본다.

1. 안정성이 검증됐는가?

	- 대형 금융사에서 수년(예: 5년 이상) 실사용되며 긍정적 피드백이 있었는지

2. 모니터링/조사(investigation) 도구가 풍부한가?

3. DBA 채용 시장이 성숙했는가?

	- 숙련 DBA를 쉽게 뽑을 수 있는지가 매우 중요

보통 NoSQL/NewSQL보다 ACID 트랜잭션 지원하는 전통적 RDB를 선호

### 테이블 관점

결제 서비스는 크게 두 개의 테이블로 “이벤트(상위) - 주문(하위)” 구조를 잡는다.

- **Payment Event(결제 이벤트)**: “한 번의 결제 행위”에 대한 상위 개념/메타 정보
- **Payment Order(결제 주문)**: 실제로 PSP에 실행되는 “주문 단위” (한 이벤트에 여러 개 가능)

### 결제 이벤트 테이블

|컬럼|타입/특징|의미|
|---|---|---|
|`checkout_id`|`string` PK|결제 이벤트 식별자 (전역적으로 고유)|
|`buyer_info`|`string`|구매자 정보|
|`seller_info`|`string`|판매자 정보|
|`credit_card_info`|“카드 제공업체마다 다름”|암호화된 카드 정보/토큰 등 (PSP 방식에 따라)|
|`is_payment_done`|`boolean`|**이 checkout_id의 모든 결제 주문이 완료(성공)** 되었는지|

### 결제 주문 테이블

|컬럼|타입/특징|의미|
|---|---|---|
|`payment_order_id`|`string` PK|결제 주문 식별자(전역 고유). PSP 중복 제거/멱등키로도 사용|
|`buyer_account`|`string`|구매자 계정|
|`amount`|`string`|금액(정밀도/반올림 이슈로 문자열 저장)|
|`currency`|`string`|통화(ISO 4217)|
|`checkout_id`|`string` FK|어떤 결제 이벤트에 속하는지|
|`payment_order_status`|`string`(enum)|주문 실행 상태 (예: NOT_STARTED/EXECUTING/SUCCESS/FAILED)|
|`ledger_updated`|`boolean`|원장 반영 여부|
|`wallet_updated`|`boolean`|지갑(판매자 잔고) 반영 여부|

## 복식부기 원장 시스템
### 1) 복식부기란?

- 원장(ledger) 시스템에서 가장 중요한 설계 원칙 중 하나가 **복식부기(double-entry)**.
- 결제/정산 같은 **모든 금융 시스템에 사실상 필수 요소**로 취급됨.
- 목적은 한 마디로: **정확한 기록 + 자금 흐름의 끝까지 추적 가능**하게 만들기.

### 2) 규칙 : 모든 거래를 2개의 계좌에 같은 금액으로 기록

- 하나의 결제 거래(transaction)는 항상
    - **한 계좌에서는 차감(debit)**,
        
    - **다른 계좌에서는 증가(credit)**
        
        로 **동일 금액**이 기록됨.
        

### 3) 특징 : 모든 거래 항목의 합계는 0이 되어야 함

- 복식부기 시스템에서는 **모든 거래 항목의 합계가 0이어야 한다.**
- “누군가 1센트를 잃으면, 다른 누군가는 1센트를 가져가야 한다”는 관점.
- 이 불변식을 지키면:
    - **돈이 어디서 빠져나가 어디로 들어갔는지**가 원장만으로 추적됨
    - 결제 주기 전체(결제→정산→환불/취소 등)에서 **일관성 검증**이 쉬워짐

### 4) 장점

- **자금 흐름을 시작부터 끝까지 추적**할 수 있음(감사/조사/대사에 매우 유리)
- 결제 시스템 전반에서 **정확성(누락/중복/불일치) 검증의 기준점**이 됨
## 외부 결제 페이지

- 대부분 기업은 **신용카드 정보를 내부에 저장하지 않는다.**
    
- 이유: 내부 저장/취급을 하면 **PCI DSS(Payment Card Industry Data Security Standard)** 같은 **복잡한 규정 준수**가 필요해지고, 보안/감사/운영 부담이 급격히 커짐.
    
    → 그래서 “카드 정보를 우리 서비스가 다루지 않는 구조”로 설계하는 게 일반적이다.
    
- 일반적으로 위젯이나 iframe 형태 로 제공 (웹)
    
- 모바일의 경우 SDK 형태로 제공
    
- **카드 정보(번호/유효기간/CVC 등)는 우리 결제 서비스가 아니라, PSP의 외부 결제 페이지가 직접 수집한다.**
    
- 우리 서버는 보통
    
    - 결제 시도에 필요한 **결제 토큰(또는 암호화된 카드 정보)**,
        
    - 그리고 결제 결과(성공/실패, 승인 ID 등)
        
        같은 “비민감/간접 정보”를 받아 결제 흐름을 이어간다.
---
# 대금 정산 흐름

- **플랫폼(전자상거래 웹사이트) 은행 계좌에 모인 돈**을
- **판매자(merchant) 은행 계좌로 이체**하는 절차
- 보통 “배송 완료/취소 가능 기간 종료” 등 **정산 조건이 충족**된 뒤 시작됨

### pay-in과 비교

**유사점**

- 구성 요소(서비스 역할)와 전체 흐름 구조는 **pay-in과 아주 유사**

**차이점(핵심)**

- pay-in: **PSP를 이용해** 구매자 신용카드 → 플랫폼 계좌로 이체
- pay-out: **타사 정산 서비스**를 이용해 플랫폼 계좌 → 판매자 계좌로 이체

### 타사 정산 서비스를 사용하는 이유 ?

- 대금 정산(pay-out)에는 **부기(회계) 및 규제 요구사항**이 추가로 따라붙음
- 그래서 결제 시스템은 보통 **외상매입금(accounts payable) 지급 서비스 제공업체**를 사용한다고 설명
---
# 상세 설계

분산 시스템에서는 다음 상황이 반드시 발생할 수 있다

- 사용자가 결제 버튼을 여러 번 누름
- 네트워크 끊김
- PSP timeout
- 내부 wallet/ledger 반영 실패
- webhook 유실
- PSP 성공했는데 우리 시스템은 실패한 경우

해결하지 못한다면 발생하는 문제:

- 중복 결제
- 돈은 빠졌는데 주문 실패
- wallet ≠ ledger
- reconciliation mismatch

해결해야 하는 문제:

- PSP 연동
- reconciliation(대사)
- 결제 지연 처리
- 내부 서비스 간 통신 방식
- 결제 실패 처리
- exactly-once 처리
- 일관성 보장
- 보안
## PSP 연동

PSP 연동은 두 가지 방식이 있음

1. API 직접 연동
2. Hosted Payment Page

### API 연동

- 회사가 카드 정보 직접 수집
- PSP는 은행 연결만 담당

```
Client → 우리 결제 서버 → PSP API
```

단점:

- PCI DSS Full Scope
- 카드정보 저장 필요
- 보안 부담 ↑
### Hosted Payment Page

- PSP 에서 제공하는 외부 결제 페이지

![[Pasted image 20260221191002.png]]
### 결제 흐름

### 1. 사용자가 결제 버튼 클릭

```
Client → Payment Service
```

결제 주문(payment order) 전달

### 2. Payment Service가 PSP에 **Payment Registration Request 전송**

이때 포함되는 정보:

- amount
- currency
- expiration
- redirect URL
- ==UUID (nonce) -> UUID가 핵심임==

```
payment_order_id = nonce
```

이 값이:

- PSP 중복 요청 방지
- idempotency key 역할
- exactly-once 보장 기반

### 3. PSP 가 토큰 반환

```
PSPToken= Payment Registration UUID
```

이 토큰으로:

- 결제 실행
- 상태 조회 가능

### 4. Payment Service 가 토큰 저장

이게 중요한 이유:

PSP 성공했는데

우리 시스템 crash 나면?

→ webhook 와도 어떤 결제인지 모름

그래서:

```
(payment_order_id ↔ PSP Token)
```

mapping 저장 필수

### Client PSP Hosted Page 노출

- Web → iframe/widget
- Mobile → PSP SDK

사용자가 카드 입력

### 6. PSP가 결제 처리 후 redirect

```
PSP →Client → Payment Complete Page
```

### 7. PSP는 서버로 **Webhook 호출**

```
PSP → Payment Service
```

결제 결과 포함됨

> [!note]
> 결제 시스템의 "진짜 source of truth"는 redirect가 아니라 webhook

왜냐하면:

- redirect는 user network 영향 받음
- webhook은 server-to-server
## Reconciliation 대사

금융 시스템에서는 반드시 불일치가 발생할 수 있다

- 아래의 반대의 경우도 발생 가능

```
우리 시스템: SUCCESS, PSP: FAILED
```

PSP settlement report 와 우리 ledger 를 비교해서 Mismatch 탐지 → Repair Job 수행
![[Pasted image 20260221191220.png]]
## 결제 지연 처리

결제 요청은 내부/외부의 여러 컴포넌트를 거치고(PSP, 카드사 등) 연동 주체도 많아서,

- 보통은 **몇 초 내 처리**되지만,
- 어떤 경우에는 **완료/거부까지 몇 시간~며칠** 걸릴 수도 있음.

즉, 결제 시스템은 “즉시 성공/실패”만 전제로 만들면 안 되고, **중간 상태(pending)** 를 **정상 케이스로** 다뤄야 함.

### 지연이 발생하는 대표 사례

- **PSP가 위험 거래로 판단**해서 **담당자(사람) 검토**를 요구하는 경우
- 카드사가 구매 확인을 위해 추가 정보를 요구하는 **3D Secure(3D 보안 인증)** 같은 보호 절차를 요구하는 경우

### Hosted Payment Page 에서 처리 방식

구매 페이지가 PSP에 호스팅되는(일반적인) 구조에서는 PSP가 다음을 수행:

1. **클라이언트에 “대기(pending)” 상태를 반환**
    - 클라이언트는 이 상태를 사용자에게 보여줌
    - 그리고 사용자가 **현재 결제 상태를 확인할 수 있는 페이지**도 제공
2. **PSP가 대기 중 결제의 진행 상황을 추적**
    - 상태가 바뀌면, 미리 등록해 둔 **웹훅(webhook)** 으로 우리 결제 서비스에 통지

### 웹훅 대신 폴링을 사용하는 PSP

- 어떤 PSP는 상태 변경을 웹훅으로 푸시하지 않고,
- 결제 서비스가 **대기 중 결제 상태를 주기적으로 조회(polling)** 하도록 요구하기도 한다.

## 내부 서비스간 커뮤니케이션

- **동기식(synchronous)**: 대표적으로 HTTP 호출
- **비동기식(asynchronous)**: 메시지 기반(큐/카프카 등)

### 동기식 호출

소규모에서는 단순하고 잘 동작하지만, **규모가 커질수록 단점이 누적**됨.

- **성능 저하**
    - 요청 처리에 관여하는 서비스가 많아질수록 end-to-end 처리 주기가 길어짐
    - 그중 하나라도 느려지면 **전체 요청이 같이 느려짐**
- **장애 격리 곤란**
    - PSP 같은 외부 의존 서비스에 장애가 나면 **클라이언트가 응답을 못 받는 형태**로 전파됨
- **높은 결합도**
    - 호출하는 쪽이 **호출 대상(수신자)을 알아야 함** → 변경/확장에 취약
- **낮은 확장성**
    - 버퍼(큐) 없이 갑작스러운 트래픽 증가에 대응하기 어렵고,
    - **확장 전략이 단순 수평확장/타임아웃 튜닝에 갇힘**

### 비동기식 호출

**A. 단일 수신자 패턴 (Queue)**

- **메시지 1개는 1개의 수신자(서비스)가 처리**
- 보통 **공유 메시지 큐**로 구현
- 구독자가 여러 개일 수는 있지만,
    - 처리된 메시지는 큐에서 제거되므로
    - 결과적으로 **각 메시지는 한 번만 소비됨**

✅ 용도: “이 작업은 누가 처리해도 되니 한 번만 처리되면 된다” (work queue)

![[Pasted image 20260221191308.png]]

**B. 다중 수신자 패턴 (Kafka)**

- **메시지 1개를 여러 서비스가 각각 소비** 가능
- 카프카는 소비자가 읽어도 메시지가 “바로 사라지지 않기” 때문에,
    - 결제 이벤트를 **결제 시스템 / 분석 / 빌링 / 푸시 알림** 등 여러 목적에 동시에 재사용 가능

✅ 용도: “동일 이벤트를 여러 도메인이 각자 처리해야 한다” (event fan-out)
![[Pasted image 20260221191326.png]]

## 결제 실패 처리

결제 시스템에서 가장 중요한 요구사항은 **안정성(Reliability) + 결함 내성(Fault Tolerance)**

결제는 아래 구간에서 실패가 가능:

- PSP API Timeout
- 네트워크 장애
- Wallet update 실패
- Ledger 기록 실패
- 내부 서비스 다운
- 사용자 잘못된 입력
- 카드 한도 초과 등

실패가 발생한 경우:

- 현재 결제 상태가 어디까지 진행됐는지 파악하고
- 재시도할지
- 환불할지
- 포기할지

를 **결정할 수 있어야 한다.**

### 결제 상태 추적

결제 주기의 **모든 단계에서 상태를 정확히 유지**하는 것이 중요함.

현재 상태를 기반으로:

- 재시도 필요 여부 판단
- 환불 필요 여부 판단

을 해야 한다

결제 상태는 **append-only(추가 전용) DB 테이블**에 저장하는 것을 권장한다

### 재시도 큐 / 실패 메시지 큐

실패를 우아하게 처리하려면 **Retry Queue + Dead Letter Queue(DLQ)** 구조가 필요함.

**Retry Queue**

- 일시적 오류(Temporary Failure)
    - 네트워크 오류
    - PSP timeout
    - 내부 서비스 다운

같이 **재시도하면 성공 가능성이 있는 경우** Retry Queue에 넣음

**Dead Letter Queue (DLQ)**

- 반복적으로 실패한 메시지
- 잘못된 입력
- 논리적으로 처리 불가능한 요청

👉 DLQ로 이동

이 큐는:

- 문제 메시지를 격리
- 디버깅
- 실패 원인 조사

를 위해 사용됨.
![[Pasted image 20260221191435.png]]
## 정확히 한 번 전달

결제 시스템에서 가장 치명적인 사고 중 하나가 **이중 결제(고객에게 두 번 청구)**

그래서 **결제 주문(payment order)이 정확히 한 번만 실행** 되도록 설계해야 함.

수학적으로 다음 두 요건이 동시에 만족되면 **Exactly-once**가 된다.

1. **최소 한 번(at-least-once)** 실행된다
2. **최대 한 번(at-most-once)** 실행된다

- (1)은 **재시도(retry)** 로 보장
- (2)는 **멱등성(idempotency check)** 로 보장

### 재시도

네트워크 오류/타임아웃 때문에 결제가 실패했을 때 **재시도로 결국 성공하게** 만들 수 있다.

**재시도 전략**

- **즉시 재시도(immediate retry)**: 실패하자마자 바로 재시도
    
- **고정 간격(fixed interval)**: 매번 일정 시간 기다렸다 재시도
    
- **증분 간격(incremental interval)**: 대기 시간을 점진적으로 늘림
    
- **지수적 백오프(exponential backoff)**: 대기 시간을 2배씩 증가
    
    예) 1초 → 2초 → 4초 …
    
- **취소(cancel)**: 영구 실패거나 성공 가능성이 낮으면 철회
    

**운영 가이드**

- “만능 전략은 없다”
- 네트워크 문제가 **단시간 내 해결이 어려워 보이면 지수적 백오프**가 일반적으로 권장
- 너무 공격적인 재시도는 **자원 낭비 + 서비스 과부하**를 유발
- 에러 응답 시 **Retry-After 헤더**를 함께 주는 게 바람직

### 멱등성

재시도는 “최소 한 번”은 보장하지만, **이중 결제 위험** 이 생긴다.

그래서 결제는 “최대 한 번”만 실행되어야 한다

**멱등키(idempotency-key) 방식**

- 클라이언트가 **UUID 같은 고유값**을 멱등키로 생성하고,
- 결제 요청에 **HTTP 헤더로 `idempotency-key: <UUID>`** 를 넣어 보냄
- 서버는 “같은 멱등키 요청”이 또 오면 **새로 결제하지 않고** “이전 요청의 최신 상태”를 반환

추가로, 동일 멱등키로 **동시 다발 요청**이 들어오면:

- 결제 서비스는 **하나만 처리**하고
- 나머지는 **429 Too Many Requests** 로 거절

**멱등성 구현 팁: DB Unique 제약 활용**

멱등성을 구현하는 쉬운 방법으로 책이 제시한 패턴:

- DB 테이블의 **기본키(PK) 또는 unique key를 멱등키로 사용**
- 동작 방식:
    1. 요청 수신 → DB에 새 레코드 insert 시도
    2. insert 성공 → “처리한 적 없는 요청” → 정상 처리
    3. insert 실패(중복 키) → “이미 처리한 요청” → 중복 처리하지 않음
![[Pasted image 20260221191516.png]]
## 일관성

결제 실행 과정에서는 **하나의 결제에 대해 여러 서비스가 각자 상태를 관리**함.

분산 환경에서 반드시 데이터 불일치가 발생할 수 있다.

### 내부/외부 서비스 간 일관성 유지 방법

1. 멱등성
    - PSP 호출 시 동일 멱등키 사용
    - 재시도 시 중복 실행 방지
    - **외부 서비스가 멱등성을 지원하더라도, 외부 시스템이 항상 옳다고 가정해서는 안된다**
2. 대사

### DB 복제로 인한 일관성 문제

복제 지연으로 인해 primary ≠ replica 상태가 발생할 수 있음

**해결 방법**

1. **Primary-only 접근**

- 모든 read/write를 Primary에서 처리

장점:

- 구현 단순

단점:

- 확장성 ↓
- Replica는 안정성용 백업일 뿐 → 리소스 낭비

1. **Strong Consistency 유지**

Replica까지 항상 동기화:

- Paxos
- Raft

같은 **합의 알고리즘** 사용

또는:

- CockroachDB
- YugabyteDB

같은 **합의 기반 분산 DB** 사용

---
# 결제 보안

### 1) 요청/응답 도청 (request/response eavesdropping)

- **위협:** 네트워크 구간에서 결제 요청/응답이 노출됨
- **대응:** **HTTPS 사용**

### 2) 데이터 변조 (data tampering)

- **위협:** 전송 중/저장 중 데이터가 위조·변경됨(금액/수신자/주문ID 등)
- **대응:** **암호화 + 무결성 강화 모니터링**
    - (실무적으로는 서명, HMAC, 해시 검증, 감사 로그 등으로 “변조 탐지”를 강화)

### 3) 중간자 공격 (man-in-the-middle attack)

- **위협:** 공격자가 통신 사이에 끼어들어 트래픽을 가로채거나 변조
- **대응:** **SSL 사용 + 인증서 고정(certificate pinning)**

### 4) 데이터 손실 (data loss)

- **위협:** DB 장애/리전 장애로 결제 기록·원장 데이터 유실 → 금융 사고
- **대응:** **여러 지역(멀티 리전) DB 복제 + 스냅샷 생성**
    - (원장/결제 이벤트는 특히 “유실 불가” 등급으로 취급)

### 5) 분산 서비스 거부 공격 (DDoS)

- **위협:** 대량 트래픽으로 결제 API/웹훅 엔드포인트 마비
- **대응:** **처리율 제한(rate limiting) + 방화벽(firewall)**

### 6) 카드 도난 (card theft)

- **위협:** 카드 번호(원문)가 유출되면 즉시 심각한 피해
- **대응:** **토큰화(tokenization)**
    - 실제 카드 번호 대신 **토큰을 저장/결제에 사용**(카드 원문을 시스템에 두지 않음)

### 7) PCI 규정 준수 (PCI compliance)

- **요지:** **PCI DSS**는 “브랜드 신용카드를 처리하는 조직”을 위한 **정보보안 표준**
- **핵심 방향:** 카드 원문을 직접 다루지 않게 설계(= 외부 결제 페이지/토큰화)해서 **PCI 범위(scope)를 최소화**하는 게 일반적인 전략

### 8) 사기(fraud)

- **위협:** 도난 카드, 계정 탈취, 봇 결제, 수상한 거래 등
- **대응:** **주소 확인(AVS), CVV 확인, 사용자 행동 분석** 등
    - (결제 전/후 리스크 엔진, 룰 기반 + ML 기반을 섞는 흐름으로 확장 가능)
---
